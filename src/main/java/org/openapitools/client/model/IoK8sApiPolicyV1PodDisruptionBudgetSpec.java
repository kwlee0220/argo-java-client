/*
 * Argo Workflows API
 * Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/latest/
 *
 * The version of the OpenAPI document: VERSION
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.IoK8sApimachineryPkgApisMetaV1LabelSelector;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-02-24T03:51:41.763920791Z[Etc/UTC]", comments = "Generator version: 7.12.0-SNAPSHOT")
public class IoK8sApiPolicyV1PodDisruptionBudgetSpec {
  public static final String SERIALIZED_NAME_MAX_UNAVAILABLE = "maxUnavailable";
  @SerializedName(SERIALIZED_NAME_MAX_UNAVAILABLE)
  @javax.annotation.Nullable
  private String maxUnavailable;

  public static final String SERIALIZED_NAME_MIN_AVAILABLE = "minAvailable";
  @SerializedName(SERIALIZED_NAME_MIN_AVAILABLE)
  @javax.annotation.Nullable
  private String minAvailable;

  public static final String SERIALIZED_NAME_SELECTOR = "selector";
  @SerializedName(SERIALIZED_NAME_SELECTOR)
  @javax.annotation.Nullable
  private IoK8sApimachineryPkgApisMetaV1LabelSelector selector;

  public static final String SERIALIZED_NAME_UNHEALTHY_POD_EVICTION_POLICY = "unhealthyPodEvictionPolicy";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_POD_EVICTION_POLICY)
  @javax.annotation.Nullable
  private String unhealthyPodEvictionPolicy;

  public IoK8sApiPolicyV1PodDisruptionBudgetSpec() {
  }

  public IoK8sApiPolicyV1PodDisruptionBudgetSpec maxUnavailable(@javax.annotation.Nullable String maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
    return this;
  }

  /**
   * Get maxUnavailable
   * @return maxUnavailable
   */
  @javax.annotation.Nullable
  public String getMaxUnavailable() {
    return maxUnavailable;
  }

  public void setMaxUnavailable(@javax.annotation.Nullable String maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
  }


  public IoK8sApiPolicyV1PodDisruptionBudgetSpec minAvailable(@javax.annotation.Nullable String minAvailable) {
    this.minAvailable = minAvailable;
    return this;
  }

  /**
   * Get minAvailable
   * @return minAvailable
   */
  @javax.annotation.Nullable
  public String getMinAvailable() {
    return minAvailable;
  }

  public void setMinAvailable(@javax.annotation.Nullable String minAvailable) {
    this.minAvailable = minAvailable;
  }


  public IoK8sApiPolicyV1PodDisruptionBudgetSpec selector(@javax.annotation.Nullable IoK8sApimachineryPkgApisMetaV1LabelSelector selector) {
    this.selector = selector;
    return this;
  }

  /**
   * Get selector
   * @return selector
   */
  @javax.annotation.Nullable
  public IoK8sApimachineryPkgApisMetaV1LabelSelector getSelector() {
    return selector;
  }

  public void setSelector(@javax.annotation.Nullable IoK8sApimachineryPkgApisMetaV1LabelSelector selector) {
    this.selector = selector;
  }


  public IoK8sApiPolicyV1PodDisruptionBudgetSpec unhealthyPodEvictionPolicy(@javax.annotation.Nullable String unhealthyPodEvictionPolicy) {
    this.unhealthyPodEvictionPolicy = unhealthyPodEvictionPolicy;
    return this;
  }

  /**
   * UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type&#x3D;\&quot;Ready\&quot;,status&#x3D;\&quot;True\&quot;.  Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.  IfHealthyBudget policy means that running pods (status.phase&#x3D;\&quot;Running\&quot;), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.  AlwaysAllow policy means that all running pods (status.phase&#x3D;\&quot;Running\&quot;), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.  Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.  This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
   * @return unhealthyPodEvictionPolicy
   */
  @javax.annotation.Nullable
  public String getUnhealthyPodEvictionPolicy() {
    return unhealthyPodEvictionPolicy;
  }

  public void setUnhealthyPodEvictionPolicy(@javax.annotation.Nullable String unhealthyPodEvictionPolicy) {
    this.unhealthyPodEvictionPolicy = unhealthyPodEvictionPolicy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoK8sApiPolicyV1PodDisruptionBudgetSpec ioK8sApiPolicyV1PodDisruptionBudgetSpec = (IoK8sApiPolicyV1PodDisruptionBudgetSpec) o;
    return Objects.equals(this.maxUnavailable, ioK8sApiPolicyV1PodDisruptionBudgetSpec.maxUnavailable) &&
        Objects.equals(this.minAvailable, ioK8sApiPolicyV1PodDisruptionBudgetSpec.minAvailable) &&
        Objects.equals(this.selector, ioK8sApiPolicyV1PodDisruptionBudgetSpec.selector) &&
        Objects.equals(this.unhealthyPodEvictionPolicy, ioK8sApiPolicyV1PodDisruptionBudgetSpec.unhealthyPodEvictionPolicy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxUnavailable, minAvailable, selector, unhealthyPodEvictionPolicy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoK8sApiPolicyV1PodDisruptionBudgetSpec {\n");
    sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
    sb.append("    minAvailable: ").append(toIndentedString(minAvailable)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    unhealthyPodEvictionPolicy: ").append(toIndentedString(unhealthyPodEvictionPolicy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxUnavailable");
    openapiFields.add("minAvailable");
    openapiFields.add("selector");
    openapiFields.add("unhealthyPodEvictionPolicy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IoK8sApiPolicyV1PodDisruptionBudgetSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IoK8sApiPolicyV1PodDisruptionBudgetSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IoK8sApiPolicyV1PodDisruptionBudgetSpec is not found in the empty JSON string", IoK8sApiPolicyV1PodDisruptionBudgetSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IoK8sApiPolicyV1PodDisruptionBudgetSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IoK8sApiPolicyV1PodDisruptionBudgetSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("maxUnavailable") != null && !jsonObj.get("maxUnavailable").isJsonNull()) && !jsonObj.get("maxUnavailable").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxUnavailable` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxUnavailable").toString()));
      }
      if ((jsonObj.get("minAvailable") != null && !jsonObj.get("minAvailable").isJsonNull()) && !jsonObj.get("minAvailable").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minAvailable` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minAvailable").toString()));
      }
      // validate the optional field `selector`
      if (jsonObj.get("selector") != null && !jsonObj.get("selector").isJsonNull()) {
        IoK8sApimachineryPkgApisMetaV1LabelSelector.validateJsonElement(jsonObj.get("selector"));
      }
      if ((jsonObj.get("unhealthyPodEvictionPolicy") != null && !jsonObj.get("unhealthyPodEvictionPolicy").isJsonNull()) && !jsonObj.get("unhealthyPodEvictionPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unhealthyPodEvictionPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unhealthyPodEvictionPolicy").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IoK8sApiPolicyV1PodDisruptionBudgetSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IoK8sApiPolicyV1PodDisruptionBudgetSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IoK8sApiPolicyV1PodDisruptionBudgetSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IoK8sApiPolicyV1PodDisruptionBudgetSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<IoK8sApiPolicyV1PodDisruptionBudgetSpec>() {
           @Override
           public void write(JsonWriter out, IoK8sApiPolicyV1PodDisruptionBudgetSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IoK8sApiPolicyV1PodDisruptionBudgetSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IoK8sApiPolicyV1PodDisruptionBudgetSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IoK8sApiPolicyV1PodDisruptionBudgetSpec
   * @throws IOException if the JSON string is invalid with respect to IoK8sApiPolicyV1PodDisruptionBudgetSpec
   */
  public static IoK8sApiPolicyV1PodDisruptionBudgetSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IoK8sApiPolicyV1PodDisruptionBudgetSpec.class);
  }

  /**
   * Convert an instance of IoK8sApiPolicyV1PodDisruptionBudgetSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

